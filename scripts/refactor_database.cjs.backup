const { createClient } = require('@supabase/supabase-js');
const https = require('https');
require('dotenv').config();

const SUPABASE_URL = process.env.SUPABASE_URL || process.env.VITE_SUPABASE_URL;
const SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY || process.env.VITE_DEEPSEEK_API_KEY;

if (!SUPABASE_URL || !SUPABASE_KEY || !DEEPSEEK_API_KEY) {
  console.error('Missing required environment variables.');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

// Function to execute SQL via Supabase REST API
async function executeSQL(sql) {
  return new Promise((resolve, reject) => {
    const url = `${SUPABASE_URL}/rest/v1/rpc/exec`;
    const data = JSON.stringify({
      sql: sql
    });

    const req = https.request(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${SUPABASE_KEY}`,
        'apikey': SUPABASE_KEY,
        'Content-Length': Buffer.byteLength(data)
      }
    }, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        if (res.statusCode === 200) {
          resolve(JSON.parse(body));
        } else {
          reject(new Error(`SQL execution failed: ${res.statusCode} ${body}`));
        }
      });
    });

    req.on('error', reject);
    req.write(data);
    req.end();
  });
}

// Function to run SQL migration
async function runSQLMigration() {
  console.log('Running SQL migration...');

  const fs = require('fs');
  const path = require('path');
  const sqlPath = path.join(__dirname, '../supabase/migrations/20251208_refactor_schema.sql');
  const sql = fs.readFileSync(sqlPath, 'utf8');

  // Split SQL into individual statements
  const statements = sql
    .split(';')
    .map(stmt => stmt.trim())
    .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'));

  for (const statement of statements) {
    if (statement.trim()) {
      console.log('Executing:', statement.substring(0, 50) + '...');
      try {
        await executeSQL(statement);
      } catch (error) {
        console.error('Error executing statement:', error.message);
        // Continue with other statements
      }
    }
  }

  console.log('SQL migration completed.');
}
  if (!text) return '';
  
  const data = JSON.stringify({
    model: "deepseek-chat",
    messages: [
      { role: "system", content: "You are a professional translator. Translate the following category name or short text. Keep it concise." },
      { role: "user", content: `Translate "${text}" to ${targetLang}. Return only the translation.` }
    ],
    temperature: 0.3
  });

  return new Promise((resolve, reject) => {
    const req = https.request({
      hostname: 'api.deepseek.com',
      path: '/chat/completions',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
        'Content-Length': Buffer.byteLength(data)
      }
    }, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        if (res.statusCode !== 200) {
          console.error(`API Error: ${res.statusCode} ${body}`);
          resolve(text);
          return;
        }
        try {
          const response = JSON.parse(body);
          resolve(response.choices[0].message.content.trim().replace(/\.$/, '')); // Remove trailing dot
        } catch (e) {
          console.error('JSON Parse Error:', e);
          resolve(text);
        }
      });
    });

    req.on('error', (e) => {
      console.error('Request Error:', e);
      resolve(text);
    });

    req.write(data);
    req.end();
  });
}

function slugify(text) {
  return text.toString().toLowerCase()
    .replace(/\s+/g, '-')           // Replace spaces with -
    .replace(/[^\w\-]+/g, '')       // Remove all non-word chars
    .replace(/\-\-+/g, '-')         // Replace multiple - with single -
    .replace(/^-+/, '')             // Trim - from start
    .replace(/-+$/, '');            // Trim - from end
}

async function main() {
  console.log('Starting database refactor migration...');

  // 1. Fetch all existing articles in smaller chunks
  console.log('Fetching articles from old table...');
  const { data: oldArticles, error: fetchError } = await supabase
    .from('articles')
    .select('slug, title, summary, content, categories, author, youtube_url, created_at')
    .limit(10); // Start with just 10 for testing

  if (fetchError) {
    console.error('Error fetching old articles:', fetchError);
    return;
  }

  console.log(`Found ${oldArticles.length} articles to migrate.`);

  if (oldArticles.length === 0) {
    console.log('No articles to migrate.');
    return;
  }

  // 2. Process Categories
  const categoryMap = new Map();
  
  // Collect all unique categories
  for (const article of oldArticles) {
    const cats = article.categories || [];
    for (const catName of cats) {
      if (!categoryMap.has(catName)) {
        categoryMap.set(catName, {
          original: catName,
          slug: slugify(await translateText(catName, 'English')),
          translations: {
            ru: catName,
            en: null,
            es: null
          }
        });
      }
    }
  }

  console.log(`Found ${categoryMap.size} unique categories. Translating...`);

  // Translate categories and insert into DB
  for (const [name, data] of categoryMap.entries()) {
    console.log(`Processing category: ${name}`);
    
    try {
      // Translate
      data.translations.en = await translateText(name, 'English');
      data.translations.es = await translateText(name, 'Spanish');
      
      // Insert into 'categories'
      const { data: catRecord, error: catError } = await supabase
        .from('categories')
        .upsert({ slug: data.slug }, { onConflict: 'slug' })
        .select()
        .single();

      if (catError) {
        console.error(`Error creating category ${data.slug}:`, catError);
        continue;
      }

      data.id = catRecord.id;

      // Insert translations
      const translations = [
        { category_id: data.id, language_code: 'ru', name: data.translations.ru },
        { category_id: data.id, language_code: 'en', name: data.translations.en },
        { category_id: data.id, language_code: 'es', name: data.translations.es }
      ];

      for (const trans of translations) {
        await supabase
          .from('category_translations')
          .upsert(trans, { onConflict: 'category_id, language_code' });
      }
    } catch (e) {
      console.error(`Error processing category ${name}:`, e.message);
    }
  }

  // 3. Migrate Articles (first 10 for testing)
  for (const article of oldArticles) {
    console.log(`Migrating article: ${article.slug}`);

    try {
      // Insert into 'articles_v2'
      const { data: newArticle, error: artError } = await supabase
        .from('articles_v2')
        .upsert({
          slug: article.slug,
          author: article.author,
          youtube_url: article.youtube_url,
          created_at: article.created_at
        }, { onConflict: 'slug' })
        .select()
        .single();

      if (artError) {
        console.error(`Error creating article_v2 ${article.slug}:`, artError);
        continue;
      }

      // Insert Translations
      const languages = ['ru', 'en', 'es'];
      
      for (const lang of languages) {
        const title = article.title?.[lang];
        const summary = article.summary?.[lang];
        const content = article.content?.[lang];

        if (title || summary || content) {
          await supabase
            .from('article_translations')
            .upsert({
              article_id: newArticle.id,
              language_code: lang,
              title: title || '',
              summary: summary || '',
              content: content || ''
            }, { onConflict: 'article_id, language_code' });
        }
      }

      // Link Categories
      const cats = article.categories || [];
      for (const catName of cats) {
        const catData = categoryMap.get(catName);
        if (catData && catData.id) {
          await supabase
            .from('article_categories')
            .upsert({
              article_id: newArticle.id,
              category_id: catData.id
            });
        }
      }
    } catch (e) {
      console.error(`Error migrating article ${article.slug}:`, e.message);
    }
  }

  console.log('Migration completed successfully!');
}

main();
